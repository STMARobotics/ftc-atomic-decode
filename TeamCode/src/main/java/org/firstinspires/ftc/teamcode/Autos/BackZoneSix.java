package org.firstinspires.ftc.teamcode.Autos;

import com.pedropathing.Drivetrain;
import com.pedropathing.geometry.BezierLine;
import com.pedropathing.geometry.Pose;
import com.pedropathing.paths.PathChain;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.seattlesolvers.solverslib.command.CommandOpMode;
import com.seattlesolvers.solverslib.command.ParallelCommandGroup;
import com.seattlesolvers.solverslib.command.SequentialCommandGroup;

import org.firstinspires.ftc.teamcode.Commands.AutoLockTurretCommand;
import org.firstinspires.ftc.teamcode.Commands.Drive;
import org.firstinspires.ftc.teamcode.Commands.FollowPathCommand;
import com.pedropathing.follower.Follower;
import org.firstinspires.ftc.teamcode.Autos.Paths.BackZoneSixPaths;
import org.firstinspires.ftc.teamcode.Commands.AutoIntakeCommand;
import org.firstinspires.ftc.teamcode.Commands.AutoShootCommand;
import org.firstinspires.ftc.teamcode.PedroPathing.Constants;
import org.firstinspires.ftc.teamcode.Subsystems.DrivetrainSubsystem;
import org.firstinspires.ftc.teamcode.Subsystems.IntakeSubsystem;
import org.firstinspires.ftc.teamcode.Subsystems.LimelightSubsystem;
import org.firstinspires.ftc.teamcode.Subsystems.PlatterSubsystem;
import org.firstinspires.ftc.teamcode.Subsystems.ShooterSubsystem;
import org.firstinspires.ftc.teamcode.Subsystems.TurretSubsystem;

/**
 * AUTO TEMPLATE GENERATED BY Pedro PP to Java v0.3.1
 *
 * HOW TO SET THIS UP:
 * 1) Ensure build.gradle has:
 *      implementation "com.pedropathing:ftc:2.x.x"
 *      implementation "com.pedropathing:telemetry:1.x.x"
 *      implementation "org.solverslib:core:0.3.x"
 *      implementation "org.solverslib:pedroPathing:0.3.x"
 *
 * 2) This class extends CommandOpMode. The lifecycle is:
 *      - initialize() is called during INIT on the driver station.
 *      - After you press PLAY, CommandScheduler runs and executes the scheduled commands.
 *
 * 3) Replace the follower initialization with your own helper if you have one.
 *      Example:
 *          follower = MyPedroFactory.createFollower(hardwareMap, telemetry);
 *
 * 4) Add and construct your subsystems in initialize(), then optionally register them.
 *      Example:
 *          private PlatterSubsystem platterSubsystem;
 *          private IntakeSubsystem intakeSubsystem;
 *          ...
 *
 *          platterSubsystem = new PlatterSubsystem(hardwareMap);
 *          intakeSubsystem  = new IntakeSubsystem(hardwareMap);
 *          ...
 *          register(platterSubsystem, intakeSubsystem, ...);
 *
 *      Then you can insert your own commands (shoot, intake, etc.) into the sequence
 *      alongside the FollowPathCommand steps.
 *
 * 5) Alliance / options selection (optional):
 *      - Override initLoop() if you want to choose alliance or tuning flags using gamepads.
 *      - Store flags (e.g. selectedAlliance, colorSortingEnabled) as fields.
 *      - Use those flags when building the command sequence in initialize().
 *
 * 6) Mirrored paths:
 *      - If you ran the converter with --mirror-alliance, this paths class also has
 *        methods like Path1Red(...), Path2Red(...).
 *      - You can choose between PathX(...) and PathXRed(...) based on alliance.
 *
 * 7) After generation:
 *      - Add @Autonomous(name = "...", group = "Autos") above this class.
 *      - Edit the SequentialCommandGroup below to insert waits, parallel groups,
 *        and mechanism commands as needed.
 */
@Autonomous(name = "BackZoneSix", group = "Autos")
public class BackZoneSix extends CommandOpMode {

    @Override
    public void initialize() {
        // TODO: Replace with your follower initialization helper if you have one
        // Pedro follower used for driving the paths

        PlatterSubsystem platterSubsystem = new PlatterSubsystem(hardwareMap);
        ShooterSubsystem shooterSubsystem = new ShooterSubsystem(hardwareMap);
        TurretSubsystem turretSubsystem = new TurretSubsystem(hardwareMap);
        LimelightSubsystem limelightSubsystem = new LimelightSubsystem(hardwareMap);
        IntakeSubsystem intakeSubsystem = new IntakeSubsystem(hardwareMap);
        DrivetrainSubsystem drivetrainSubsystem = new DrivetrainSubsystem(hardwareMap);
        register(platterSubsystem, shooterSubsystem, turretSubsystem, limelightSubsystem, intakeSubsystem, drivetrainSubsystem);

        Follower follower = drivetrainSubsystem.getFollower();

        // Schedule the generated path sequence
//        schedule(
//                new ParallelCommandGroup(
//                        new AutoLockTurretCommand(turretSubsystem, limelightSubsystem, shooterSubsystem),
//                        new AutoShootCommand(platterSubsystem, shooterSubsystem, turretSubsystem, limelightSubsystem))
//                        .andThen(
//                                new ParallelCommandGroup(
//                                        new AutoIntakeCommand(platterSubsystem, intakeSubsystem),
//                                        new SequentialCommandGroup(
//                                                new FollowPathCommand(StartPath1, follower, Path1(follower), drivetrainSubsystem),
//                                                new FollowPathCommand(StartPath2, follower, Path2(follower), drivetrainSubsystem)))
//                                        .andThen(
//                                                new ParallelCommandGroup(
//                                                        new AutoLockTurretCommand(turretSubsystem, limelightSubsystem, shooterSubsystem),
//                                                        new AutoShootCommand(platterSubsystem, shooterSubsystem, turretSubsystem, limelightSubsystem)
//                                                ))));

        schedule(
                new SequentialCommandGroup(
                        new FollowPathCommand(StartPath1, follower, Path1(follower), drivetrainSubsystem),
                        new FollowPathCommand(StartPath2, follower, Path2(follower), drivetrainSubsystem
                )));
    }
    public Pose StartPath1 = new Pose(53.51196172248804, 8.1, Math.toRadians(180.0));
    public static PathChain Path1(Follower follower) {
        return follower.pathBuilder()
                .addPath(new BezierLine(new Pose(53.51196172248804, 8.1, Math.toRadians(180.0)), new Pose(22.507177033492823, 8.1, Math.toRadians(180.0))))
                .setLinearHeadingInterpolation(
                        Math.toRadians(180.0),
                        Math.toRadians(180.0))
                .build();
    }

    public Pose StartPath2 = new Pose(22.507177033492823, 8.1, Math.toRadians(180.0));
    public static PathChain Path2(Follower follower) {
        return follower.pathBuilder()
                .addPath(new BezierLine(new Pose(22.507177033492823, 8.1, Math.toRadians(180.0)), new Pose(57.5, 20, Math.toRadians(0.0))))
                .setLinearHeadingInterpolation(
                        Math.toRadians(180.0),
                        Math.toRadians(0.0))
                .build();
    }
}